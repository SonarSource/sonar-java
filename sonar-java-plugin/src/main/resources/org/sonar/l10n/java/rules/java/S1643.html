<h2>Why is this an issue?</h2>
<p>Strings are immutable objects, so concatenation doesn’t simply add the new String to the end of the existing string. Instead, in each loop
iteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted
back to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is
preferred.</p>
<h3>Noncompliant code example</h3>
<pre>
String str = "";
for (int i = 0; i &lt; arrayOfStrings.length ; ++i) {
  str = str + arrayOfStrings[i];
}
</pre>
<h3>Compliant solution</h3>
<pre>
StringBuilder bld = new StringBuilder();
  for (int i = 0; i &lt; arrayOfStrings.length; ++i) {
    bld.append(arrayOfStrings[i]);
  }
  String str = bld.toString();
</pre>
<table>
  <colgroup>
    <col style="width: 20%;">
    <col style="width: 20%;">
    <col style="width: 20%;">
    <col style="width: 20%;">
    <col style="width: 20%;">
  </colgroup>
  <thead>
    <tr>
      <th>Method</th>
      <th>size</th>
      <th>Runtime</th>
      <th>Average time</th>
      <th>Error margin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p>plus</p></td>
      <td><p>100</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>4.19 µs/op</p></td>
      <td><p>±0.34 µs/op</p></td>
    </tr>
    <tr>
      <td><p>plus</p></td>
      <td><p>1000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>377.08 µs/op</p></td>
      <td><p>±17.36 µs/op</p></td>
    </tr>
    <tr>
      <td><p>plus</p></td>
      <td><p>10000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>40221.49 µs/op</p></td>
      <td><p>±1342.76 µs/op</p></td>
    </tr>
    <tr>
      <td><p>plus</p></td>
      <td><p>100000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>5286840.53 µs/op</p></td>
      <td><p>±185796.75 µs/op</p></td>
    </tr>
    <tr>
      <td><p>stringBuilder</p></td>
      <td><p>100</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>0.97 µs/op</p></td>
      <td><p>±0.03 µs/op</p></td>
    </tr>
    <tr>
      <td><p>stringBuilder</p></td>
      <td><p>1000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>10.25 µs/op</p></td>
      <td><p>±1.64 µs/op</p></td>
    </tr>
    <tr>
      <td><p>stringBuilder</p></td>
      <td><p>10000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>93.27 µs/op</p></td>
      <td><p>±16.05 µs/op</p></td>
    </tr>
    <tr>
      <td><p>stringBuilder</p></td>
      <td><p>100000</p></td>
      <td><p>Temurin 21</p></td>
      <td><p>1019.91 µs/op</p></td>
      <td><p>±69.58 µs/op</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Benchmarking code</strong></p>
<p>The results were generated by running the following snippet with <a href="https://github.com/openjdk/jmh">JMH</a>.</p>
<pre>
@Param({"100", "1000", "10000", "100000"})
int size;
private String word = "append";

@Benchmark
public String plus() {
  String str = "";
  for (int i = 0; i &lt; size; i++) {
    str = str + word;
  }
  return str;
}

@Benchmark
public String stringBuilder() {
  StringBuilder builder = new StringBuilder();
  for (int i = 0; i &lt; size; i++) {
    builder.append(word);
  }
  return builder.toString();
}
</pre>

