<p>The Singleton design pattern is a creational pattern. It ensures that only one instance of a class is created and provides a global point of access
to it. In Java, there are several ways to implement a Singleton, and the debate about the best approach has yet to be settled.</p>
<p>This rule marks all classes that are considered as Singletons, regardless of how they are implemented. This helps developers identifying where in
the code Singletons are used. Singletons should be reviewed to confirm whether or not a Singleton is truly necessary and whether the selected
implementation is the most suitable for the context.</p>
<p>Every Singleton implementation has its advantages and disadvantages. This rule exists to bring attention to them, so that informed decisions can be
made.</p>
<h2>Why is this an issue?</h2>
<p>While the Singleton pattern can be useful in certain situations, overusing it can have several drawbacks:</p>
<ul>
  <li> Tight coupling: The Singleton pattern can create tight coupling between the Singleton class and other classes that use it, which can make the
  code difficult to maintain and modify. </li>
  <li> Global state: The Singleton pattern can create global state, which can make it difficult to manage the state of the application and can lead to
  unexpected behavior. </li>
  <li> Testing: The Singleton pattern can make it difficult to test classes that depend on the Singleton, as the Singleton cannot be easily
  substituted with a mock object. </li>
  <li> Scalability: The Singleton pattern can make it difficult to scale an application, as it can create a bottleneck if multiple threads try to
  access the Singleton concurrently. </li>
  <li> Dependency injection: The Singleton pattern can make it difficult to use dependency injection frameworks, as the Singleton instance is usually
  created statically. </li>
</ul>
<p>In general, the Singleton pattern should be used sparingly and only in situations where it provides a clear benefit over other patterns or
approaches. It is important to consider the drawbacks and tradeoffs of using the Singleton pattern before incorporating it into an application.</p>
<h2>How to fix it in Eager Initialization</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Static Block Initialization</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Lazy Initialization</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Thread Safe Singleton</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Bill Pugh Singleton Implementation</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Using Reflection to destroy Singleton Pattern</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Enum Singleton</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>
<h2>How to fix it in Serialization and Singleton</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
FIXME
</pre>
<h4>Compliant solution</h4>
<pre>
FIXME
</pre>

