<p>Most checks against an <code>indexOf</code> value compare it with -1 because 0 is a valid index. Any checks which look for values &gt;0 ignore the first element, which is likely a bug.
If the intent is merely to check inclusion of a value in a <code>String</code> or a <code>List</code>, consider using the <code>contains</code> method instead.</p>

<p>For strings, if the intent is truly to find the first index after a specific character index, then use the version of <code>indexOf</code> which takes a start position argument.</p>

<p>This rule raises an issue any time an <code>indexOf</code> value retrieved either from a <code>String</code> or a <code>List</code> is tested for a positive value.</p>

<h2>Noncompliant Code Example</h2>

<pre>
String color = "blue";
String name = "ishmael";

List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add(color);
strings.add(name);

if (strings.indexOf(color) &gt; 0) {  // Noncompliant
  // ...
}
if (name.indexOf("ish") &gt; 0) { // Noncompliant
  // ...
}
if (name.indexOf("hma") &gt; 2) { // Noncompliant
  // ...
}
</pre>

<h2>Compliant Solution</h2>

<pre>
String color = "blue";
String name = "ishmael";

List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add(color);
strings.add(name);

if (strings.indexOf(color) &gt; -1) {
  // ...
}
if (name.indexOf("ish") &gt;= 0) {
  // ...
}
if (name.indexOf("hma") &gt; -1) {
  // ...
}
</pre>
